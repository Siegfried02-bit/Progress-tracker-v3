<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Progress Tracker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Ajoutez ce style pour les confettis, si vous utilisez une approche CSS/JS simple */
    @keyframes confetti-fall {
        0% { transform: translateY(-100vh) rotate(0deg); opacity: 0; }
        10% { opacity: 1; }
        100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    .confetti {
        position: fixed;
        width: 10px;
        height: 10px;
        background-color: #f0f; /* Exemple de couleur */
        opacity: 0;
        animation: confetti-fall 3s ease-out forwards;
        z-index: 9999;
        border-radius: 50%; /* Pour des confettis ronds */
    }
  </style>
</head>
<body>
  <div class="header-nav">
    <button id="goalsButton" onclick="showView('goalsView')">Objectifs</button>
    <button id="notesButton" onclick="showView('notesView')">Notes</button>
    <button id="settingsButton" onclick="showView('settingsView')">Paramètres</button>
  </div>

  <div id="goalsView" class="view">
    <h1>Progress Tracker</h1>

    <div class="main-content-flex">
        <div class="left-panel">
            <div class="add-goal-section">
                <h2>Ajouter un nouvel objectif :</h2>
                <label>Nom de l'objectif : <input type="text" id="newName"></label>
                <span class="error-message" id="error-newName"></span><br>

                <label>Type d'objectif :
                    <select id="newGoalType" onchange="toggleGoalTypeFields()">
                        <option value="numeric">Numérique (ex: lire X pages)</option>
                        <option value="boolean">À faire (ex: terminer une tâche)</option>
                        <option value="recurring">Récurrent (ex: quotidien)</option>
                    </select>
                </label><br>

                <div id="numericGoalFields">
                    <label>Cible : <input type="number" id="newTarget"></label>
                    <span class="error-message" id="error-newTarget"></span><br>
                    <label>Unité (optionnel) : <input type="text" id="newUnit"></label><br>
                </div>

                <div id="recurringGoalFields" style="display:none;">
                    <label>Fréquence :
                        <select id="newFrequency">
                            <option value="daily">Quotidien</option>
                            <option value="weekly">Hebdomadaire</option>
                            <option value="monthly">Mensuel</option>
                        </select>
                    </label><br>
                </div>

                <label>Catégorie :
                    <select id="newCategory"></select>
                </label>
                <button onclick="addNewCategory()">Nouvelle Catégorie</button><br>
                <input type="text" id="newCategoryName" placeholder="Nom de la nouvelle catégorie" style="display:none;"><br>
                <button onclick="saveNewCategory()" style="display:none;" id="saveCategoryButton">Ajouter Catégorie</button>
                <span class="error-message" id="error-newCategory"></span><br>

                <button onclick="addGoal()">Ajouter Objectif</button>
            </div>
        </div>

        <div class="right-panel">
            <div class="goals-list-section">
                <h2>Mes Objectifs :</h2>
                <label>Filtrer par Catégorie:
                    <select id="filterCategory" onchange="renderGoals()"></select>
                </label>
                <button onclick="showCompletedGoals()">Afficher Complétés</button>
                <button onclick="showActiveGoals()">Afficher Actifs</button>
                <div id="goalsContainer" data-filter="active"></div> </div>
            <div class="stats-section">
                <h2>Statistiques :</h2>
                <p>Objectifs Totaux : <span id="totalGoals">0</span></p>
                <p>Objectifs Atteints : <span id="completedGoalsCount">0</span></p>
            </div>
        </div>
    </div>
  </div>

  <div id="notesView" class="view" style="display:none;">
    <h1>Mes Notes</h1>
    <div class="add-note-section">
        <h2>Ajouter une nouvelle note :</h2>
        <textarea id="noteText" placeholder="Écrivez votre note ici..."></textarea><br>
        <button onclick="addNote()">Ajouter Note</button>
    </div>
    <div id="notesContainer"></div>
  </div>

  <div id="settingsView" class="view" style="display:none;">
    <h1>Paramètres</h1>
    <div class="settings-section">
        <h2>Préférences d'affichage</h2>
        <label class="switch">
            <input type="checkbox" id="darkModeToggle">
            <span class="slider round"></span>
        </label>
        Mode Sombre<br>
        <button onclick="requestNotificationPermission()">Activer Notifications</button>
    </div>
    <div class="settings-section">
        <h2>Gestion des Données</h2>
        <button onclick="exportData()">Exporter Mes Données</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)"><br>
    </div>
    <div class="settings-section">
        <h2>Gestion des Catégories</h2>
        <div id="categoryManagement"></div>
    </div>
  </div>


  <script type="text/javascript">
    let goals = [];
    let notes = [];
    let categories = ['Général']; // Catégorie par défaut
    let activeTimerId = null; // Pour stocker l'ID de l'objectif dont le chronomètre est actif
    let timerStartTime = null; // Quand le chronomètre a démarré
    let timerInterval = null; // L'intervalle du chronomètre
    let activeCharts = {}; // Pour stocker les instances de Chart.js

    const saveGoals = () => {
        localStorage.setItem('goals', JSON.stringify(goals));
        updateStats(); // Mettre à jour les statistiques après chaque sauvegarde
    };

    const loadGoals = () => {
        const storedGoals = localStorage.getItem('goals');
        if (storedGoals) {
            goals = JSON.parse(storedGoals);
            // Assurer que les anciens objectifs ont les nouveaux champs pour éviter les erreurs
            goals.forEach(goal => {
                if (goal.type === 'numeric' && !goal.progressHistory) {
                    goal.progressHistory = [];
                }
                if (goal.completed === undefined) {
                    goal.completed = false;
                }
                if (goal.type === 'numeric' && goal.currentTimerTime === undefined) {
                    goal.currentTimerTime = 0;
                }
                if (goal.type === 'recurring' && !goal.checkedDates) {
                    goal.checkedDates = {};
                }
            });
        }
        const storedCategories = localStorage.getItem('categories');
        if (storedCategories) {
            categories = JSON.parse(storedCategories);
        }
        renderGoals(); // Rendre les objectifs après le chargement
        populateCategorySelect('newCategory');
        populateCategorySelect('filterCategory');
        populateCategoryManagement();
    };

    const saveNotes = () => {
        localStorage.setItem('notes', JSON.stringify(notes));
    };

    const loadNotes = () => {
        const storedNotes = localStorage.getItem('notes');
        if (storedNotes) {
            notes = JSON.parse(storedNotes);
        }
        renderNotes();
    };

    const addGoal = () => {
        const name = document.getElementById('newName').value.trim();
        const goalType = document.getElementById('newGoalType').value;
        const category = document.getElementById('newCategory').value;

        // Réinitialiser les messages d'erreur
        document.getElementById('error-newName').textContent = '';
        document.getElementById('error-newTarget').textContent = '';
        document.getElementById('error-newCategory').textContent = '';

        let isValid = true;

        if (!name) {
            document.getElementById('error-newName').textContent = 'Le nom de l\'objectif est requis.';
            isValid = false;
        }

        let newGoal;
        if (goalType === 'numeric') {
            const target = parseInt(document.getElementById('newTarget').value);
            const unit = document.getElementById('newUnit').value.trim();

            if (isNaN(target) || target <= 0) {
                document.getElementById('error-newTarget').textContent = 'La cible doit être un nombre positif.';
                isValid = false;
            }

            if (isValid) {
                newGoal = {
                    name,
                    type: goalType,
                    target,
                    current: 0,
                    unit,
                    category,
                    completed: false,
                    progressHistory: [],
                    currentTimerTime: 0
                };
            }
        } else if (goalType === 'boolean') {
            if (isValid) {
                newGoal = {
                    name,
                    type: goalType,
                    completed: false,
                    category,
                    done: false
                };
            }
        } else if (goalType === 'recurring') {
            const frequency = document.getElementById('newFrequency').value;
            if (isValid) {
                newGoal = {
                    name,
                    type: goalType,
                    category,
                    frequency,
                    completed: false,
                    checkedDates: {}
                };
            }
        }


        if (isValid && newGoal) {
            goals.push(newGoal);
            saveGoals();
            document.getElementById('newName').value = '';
            if (goalType === 'numeric') {
                document.getElementById('newTarget').value = '';
                document.getElementById('newUnit').value = '';
            }
            renderGoals();
        }
    };

    function updateGoal(index) {
        const goal = goals[index];

        if (goal.type === 'numeric') {
            const progressInput = document.getElementById(`progress-${index}`);
            const progress = parseInt(progressInput.value);

            if (!isNaN(progress) && progress > 0) {
                goal.current += progress;
                // Enregistrer dans l'historique
                goal.progressHistory.push({
                    date: new Date().toLocaleString('fr-FR', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit'
                    }),
                    amount: progress
                });

                if (goal.current >= goal.target) {
                    goal.current = goal.target;
                    goal.completed = true; // Marquer comme complété
                    triggerCelebration(); // Déclencher la célébration
                }
                saveGoals();
                renderGoals();
                progressInput.value = '';
            } else {
                alert('Veuillez entrer un nombre positif pour le progrès.');
            }
        } else if (goal.type === 'boolean') {
            goal.done = !goal.done;
            goal.completed = goal.done; // Un objectif booléen est complété quand il est "fait"
            if (goal.done) {
                triggerCelebration(); // Déclencher la célébration si marqué comme fait
            }
            saveGoals();
            renderGoals();
        }
    }

    // --- Célébrations ---
    function triggerCelebration() {
        const container = document.body;
        for (let i = 0; i < 50; i++) { // 50 confettis
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
            confetti.style.animationDelay = `${Math.random() * 2}s`;
            container.appendChild(confetti);
            // Supprimer le confetti après l'animation
            confetti.addEventListener('animationend', () => {
                confetti.remove();
            });
        }
    }

    // --- Affichage des objectifs ---
    function renderGoals() {
        const container = document.getElementById('goalsContainer');
        container.innerHTML = '';
        const filterCategory = document.getElementById('filterCategory').value;
        const currentFilterMode = container.dataset.filter || 'active'; // 'active' par défaut

        let filteredGoals = goals.filter(goal => {
            if (currentFilterMode === 'completed') {
                return goal.completed;
            } else { // active
                return !goal.completed;
            }
        });

        if (filterCategory !== 'all') {
            filteredGoals = filteredGoals.filter(goal => goal.category === filterCategory);
        }

        // Détruire tous les graphiques existants avant de les recréer
        for (const chartId in activeCharts) {
            if (activeCharts[chartId]) {
                activeCharts[chartId].destroy();
            }
        }
        activeCharts = {}; // Réinitialiser le cache

        filteredGoals.forEach((goal, index) => {
            // Trouver l'index original de l'objectif dans le tableau global 'goals'
            const originalIndex = goals.findIndex(g => g === goal);

            const goalDiv = document.createElement('div');
            goalDiv.className = 'goal';
            if (goal.completed) {
                goalDiv.classList.add('goal-completed'); // Ajoutez une classe pour styliser les objectifs complétés
            }

            let goalContent = `<h3>${goal.name}</h3>`;

            if (goal.type === 'numeric') {
                const percentage = (goal.current / goal.target) * 100;
                goalContent += `
                    <p>Progrès: ${goal.current} / ${goal.target} ${goal.unit ? goal.unit : ''} (${percentage.toFixed(1)}%)</p>
                    <div class="progress-bar"><div class="progress" style="width: ${percentage}%"></div></div>
                    <div class="numeric-controls">
                        <label>Ajouter progrès: <input type="number" id="progress-${originalIndex}" min="1"></label>
                        <button onclick="updateGoal(${originalIndex})">Mettre à jour</button>
                        <button onclick="startStopTimer(${originalIndex})" id="timerBtn-${originalIndex}">${activeTimerId === originalIndex ? 'Stop Timer' : 'Start Timer'}</button>
                        <span id="timerDisplay-${originalIndex}" class="timer-display">${goal.currentTimerTime ? formatTime(goal.currentTimerTime) : '00:00:00'}</span>
                    </div>
                    <button class="toggle-history-btn" onclick="toggleProgressHistory(${originalIndex})">Voir Historique</button>
                    <div id="progressHistory-${originalIndex}" class="progress-history-list"></div>
                    <button class="toggle-chart-btn" onclick="toggleProgressChart(${originalIndex})">Voir Graphique</button>
                    <div class="chart-container" id="chartContainer-${originalIndex}" style="display: none;">
                        <canvas id="progressChart-${originalIndex}"></canvas>
                    </div>
                    <div class="reminder-section">
                        <label>Rappel dans (min) : <input type="number" id="reminderTime-${originalIndex}" min="1"></label>
                        <button onclick="scheduleGoalReminder('${goal.name.replace(/'/g, "\\'")}', document.getElementById('reminderTime-${originalIndex}').value, ${originalIndex})">Définir Rappel</button>
                    </div>
                `;
            } else if (goal.type === 'boolean') {
                goalContent += `
                    <label class="checkbox-container">Terminé
                        <input type="checkbox" ${goal.done ? 'checked' : ''} onclick="updateGoal(${originalIndex})">
                        <span class="checkmark"></span>
                    </label>
                     <div class="reminder-section">
                        <label>Rappel dans (min) : <input type="number" id="reminderTime-${originalIndex}" min="1"></label>
                        <button onclick="scheduleGoalReminder('${goal.name.replace(/'/g, "\\'")}', document.getElementById('reminderTime-${originalIndex}').value, ${originalIndex})">Définir Rappel</button>
                    </div>
                `;
            } else if (goal.type === 'recurring') {
                const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
                const isCheckedToday = goal.checkedDates[today] || false;
                goalContent += `
                    <p>Fréquence: ${goal.frequency}</p>
                    <label class="checkbox-container">Fait aujourd'hui (${today})
                        <input type="checkbox" ${isCheckedToday ? 'checked' : ''} onclick="toggleRecurringGoal(${originalIndex})">
                        <span class="checkmark"></span>
                    </label>
                    <button class="toggle-history-btn" onclick="showRecurringLog(${originalIndex})">Voir Calendrier</button>
                    <div id="recurringLog-${originalIndex}" class="recurring-log-list" style="display:none;"></div>
                    <div class="reminder-section">
                        <label>Rappel dans (min) : <input type="number" id="reminderTime-${originalIndex}" min="1"></label>
                        <button onclick="scheduleGoalReminder('${goal.name.replace(/'/g, "\\'")}', document.getElementById('reminderTime-${originalIndex}').value, ${originalIndex})">Définir Rappel</button>
                    </div>
                `;
            }

            goalContent += `
                <p class="goal-category">Catégorie: ${goal.category}</p>
                <button class="delete-btn" onclick="deleteGoal(${originalIndex})">Supprimer</button>
                <button class="complete-btn" onclick="toggleGoalCompletion(${originalIndex})">
                    ${goal.completed ? 'Réactiver' : 'Marquer comme Complété'}
                </button>
            `;
            goalDiv.innerHTML = goalContent;
            container.appendChild(goalDiv);
        });
    }

    function showCompletedGoals() {
        document.getElementById('goalsContainer').dataset.filter = 'completed';
        renderGoals();
    }

    function showActiveGoals() {
        document.getElementById('goalsContainer').dataset.filter = 'active';
        renderGoals();
    }

    // --- Fonction d'archivage/complétion ---
    function toggleGoalCompletion(index) {
        goals[index].completed = !goals[index].completed;
        saveGoals();
        renderGoals();
    }

    // --- Historique détaillé des ajouts de progrès ---
    function toggleProgressHistory(index) {
        const historyDiv = document.getElementById(`progressHistory-${index}`);
        const goal = goals[index];
        if (historyDiv.style.display === 'block') {
            historyDiv.style.display = 'none';
        } else {
            historyDiv.innerHTML = '<h4>Historique de Progrès :</h4>';
            if (goal.progressHistory && goal.progressHistory.length > 0) {
                const ul = document.createElement('ul');
                goal.progressHistory.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `+${entry.amount} le ${entry.date}`;
                    ul.appendChild(li);
                });
                historyDiv.appendChild(ul);
            } else {
                historyDiv.innerHTML += '<p>Aucun historique de progrès pour cet objectif.</p>';
            }
            historyDiv.style.display = 'block';
        }
    }

    // --- Graphiques de Progression ---
    function toggleProgressChart(index) {
        const chartContainer = document.getElementById(`chartContainer-${index}`);
        const goal = goals[index];

        if (chartContainer.style.display === 'block') {
            chartContainer.style.display = 'none';
            // Détruire l'instance de Chart.js pour éviter les problèmes de mise à jour
            if (activeCharts[index]) {
                activeCharts[index].destroy();
                delete activeCharts[index];
            }
        } else {
            chartContainer.style.display = 'block';
            renderProgressChart(index, goal);
        }
    }

    function renderProgressChart(index, goal) {
        const ctx = document.getElementById(`progressChart-${index}`).getContext('2d');

        // Détruire l'instance précédente si elle existe
        if (activeCharts[index]) {
            activeCharts[index].destroy();
        }

        const labels = goal.progressHistory.map(entry => {
            const datePart = entry.date.split(' ')[0]; // JJ/MM/AAAA
            const [day, month, year] = datePart.split('/');
            return `${day}/${month}`; // Afficher JJ/MM
        });

        const data = [];
        let cumulativeProgress = 0;
        goal.progressHistory.forEach(entry => {
            cumulativeProgress += entry.amount;
            data.push(cumulativeProgress);
        });

        // Ajouter le progrès actuel si l'historique est vide ou si le dernier ajout n'a pas mis à jour le graphique (ex: après un timer)
        if (data.length === 0 || data[data.length - 1] !== goal.current) {
            labels.push(new Date().toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
            data.push(goal.current);
        }


        activeCharts[index] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: `Progrès de ${goal.name}`,
                    data: data,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    fill: false,
                    pointRadius: 3,
                    pointHoverRadius: 5
                },
                {
                    label: 'Cible',
                    data: Array(labels.length).fill(goal.target),
                    borderColor: 'rgb(255, 99, 132)',
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: `${goal.unit ? goal.unit : 'Unités'}`
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    }
                }
            }
        });
    }

    const deleteGoal = (index) => {
        if (confirm('Êtes-vous sûr de vouloir supprimer cet objectif ?')) {
            goals.splice(index, 1);
            saveGoals();
            renderGoals();
        }
    };

    const updateStats = () => {
        document.getElementById('totalGoals').textContent = goals.length;
        const completedCount = goals.filter(goal => goal.completed).length;
        document.getElementById('completedGoalsCount').textContent = completedCount;
    };

    // --- Catégories ---
    function populateCategorySelect(selectId) {
        const selectElement = document.getElementById(selectId);
        selectElement.innerHTML = '<option value="all">Toutes les catégories</option>'; // Option par défaut pour le filtre
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            selectElement.appendChild(option);
        });
    }

    function addNewCategory() {
        document.getElementById('newCategoryName').style.display = 'inline-block';
        document.getElementById('saveCategoryButton').style.display = 'inline-block';
    }

    function saveNewCategory() {
        const newCatName = document.getElementById('newCategoryName').value.trim();
        document.getElementById('error-newCategory').textContent = '';
        if (newCatName && !categories.includes(newCatName)) {
            categories.push(newCatName);
            localStorage.setItem('categories', JSON.stringify(categories));
            populateCategorySelect('newCategory');
            populateCategorySelect('filterCategory');
            populateCategoryManagement(); // Mettre à jour la liste de gestion des catégories
            document.getElementById('newCategoryName').value = '';
            document.getElementById('newCategoryName').style.display = 'none';
            document.getElementById('saveCategoryButton').style.display = 'none';
        } else if (!newCatName) {
            document.getElementById('error-newCategory').textContent = 'Le nom de la catégorie ne peut pas être vide.';
        } else {
            document.getElementById('error-newCategory').textContent = 'Cette catégorie existe déjà.';
        }
    }

    // Nouvelle fonction pour gérer les catégories (édition/suppression)
    function populateCategoryManagement() {
        const container = document.getElementById('categoryManagement');
        container.innerHTML = '<h3>Modifier/Supprimer les Catégories :</h3>';
        if (categories.length === 0) {
            container.innerHTML += '<p>Aucune catégorie définie.</p>';
            return;
        }
        const ul = document.createElement('ul');
        categories.forEach(cat => {
            const li = document.createElement('li');
            li.innerHTML = `
                <span>${cat}</span>
                ${cat !== 'Général' ? `<button onclick="deleteCategory('${cat}')">Supprimer</button>` : ''}
            `;
            ul.appendChild(li);
        });
        container.appendChild(ul);
    }

    function deleteCategory(catToDelete) {
        if (confirm(`Êtes-vous sûr de vouloir supprimer la catégorie "${catToDelete}" ? Les objectifs de cette catégorie seront déplacés vers "Général".`)) {
            categories = categories.filter(cat => cat !== catToDelete);
            localStorage.setItem('categories', JSON.stringify(categories));

            // Déplacer les objectifs de la catégorie supprimée vers 'Général'
            goals.forEach(goal => {
                if (goal.category === catToDelete) {
                    goal.category = 'Général';
                }
            });
            saveGoals(); // Sauvegarder les objectifs mis à jour

            populateCategorySelect('newCategory');
            populateCategorySelect('filterCategory');
            populateCategoryManagement();
            renderGoals(); // Rerendre les objectifs avec les catégories mises à jour
        }
    }


    // --- Chronomètre ---
    function startStopTimer(index) {
        if (activeTimerId === index) { // Si le chronomètre pour cet objectif est déjà actif, l'arrêter
            clearInterval(timerInterval);
            activeTimerId = null;
            timerStartTime = null;
            document.getElementById(`timerBtn-${index}`).textContent = 'Start Timer';
            // Le currentTimerTime est déjà sauvegardé par updateTimerDisplay
        } else { // Démarrer le chronomètre pour cet objectif
            // Arrêter tout autre chronomètre actif
            if (activeTimerId !== null) {
                clearInterval(timerInterval);
                document.getElementById(`timerBtn-${activeTimerId}`).textContent = 'Start Timer';
            }

            activeTimerId = index;
            timerStartTime = Date.now(); // L'heure de début du chronomètre

            // Initialiser currentTimerTime si c'est la première fois ou si l'objectif n'a pas de temps enregistré
            if (goals[index].currentTimerTime === undefined) {
                goals[index].currentTimerTime = 0;
            }

            document.getElementById(`timerBtn-${index}`).textContent = 'Stop Timer';
            timerInterval = setInterval(() => updateTimerDisplay(index), 1000);
        }
        saveGoals(); // Sauvegarder le changement d'état du timer
        renderGoals(); // Rafraîchir l'affichage pour mettre à jour le bouton
    }

    function updateTimerDisplay(index) {
        const elapsed = Date.now() - timerStartTime;
        goals[index].currentTimerTime += elapsed; // Ajouter le temps écoulé au temps total de l'objectif
        timerStartTime = Date.now(); // Réinitialiser le temps de début pour le prochain intervalle

        const timerDisplay = document.getElementById(`timerDisplay-${index}`);
        if (timerDisplay) {
            timerDisplay.textContent = formatTime(goals[index].currentTimerTime);
        }
        saveGoals(); // Sauvegarder fréquemment l'état du timer
    }

    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }


    // --- Notes ---
    const addNote = () => {
        const noteText = document.getElementById('noteText').value.trim();
        if (noteText) {
            notes.push({ text: noteText, date: new Date().toLocaleString('fr-FR') });
            saveNotes();
            document.getElementById('noteText').value = '';
            renderNotes();
        }
    };

    const deleteNote = (index) => {
        if (confirm('Êtes-vous sûr de vouloir supprimer cette note ?')) {
            notes.splice(index, 1);
            saveNotes();
            renderNotes();
        }
    };

    const renderNotes = () => {
        const container = document.getElementById('notesContainer');
        container.innerHTML = '';
        notes.forEach((note, index) => {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'note';
            noteDiv.innerHTML = `
                <p>${note.text}</p>
                <small>${note.date}</small>
                <button onclick="deleteNote(${index})">Supprimer</button>
            `;
            container.appendChild(noteDiv);
        });
    };

    // --- Vues (Goals, Notes, Settings) ---
    const showView = (viewId) => {
        document.querySelectorAll('.view').forEach(view => {
            view.style.display = 'none';
        });
        document.getElementById(viewId).style.display = 'block';

        // Gérer les classes 'active' pour les boutons de navigation
        document.querySelectorAll('.header-nav button').forEach(button => {
            button.classList.remove('active');
        });
        if (viewId === 'goalsView') {
            document.getElementById('goalsButton').classList.add('active');
        } else if (viewId === 'notesView') {
            document.getElementById('notesButton').classList.add('active');
        } else if (viewId === 'settingsView') {
            document.getElementById('settingsButton').classList.add('active');
        }
    };


    // --- Import / Export ---
    function exportData() {
        const data = {
            goals: goals,
            notes: notes,
            categories: categories
        };
        const dataStr = JSON.stringify(data, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'progress_tracker_data.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function importData(event) {
        const file = event.target.files[0];
        if (!file) {
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (confirm('Importer les données va remplacer vos données actuelles. Continuer ?')) {
                    if (importedData.goals) {
                        goals = importedData.goals;
                        // Assurez-vous que les anciens objectifs ont les nouveaux champs
                        goals.forEach(goal => {
                            if (goal.type === 'numeric' && !goal.progressHistory) {
                                goal.progressHistory = [];
                            }
                            if (goal.completed === undefined) {
                                goal.completed = false;
                            }
                            if (goal.type === 'numeric' && goal.currentTimerTime === undefined) {
                                goal.currentTimerTime = 0;
                            }
                            if (goal.type === 'recurring' && !goal.checkedDates) {
                                goal.checkedDates = {};
                            }
                        });
                        saveGoals();
                    }
                    if (importedData.notes) {
                        notes = importedData.notes;
                        saveNotes();
                    }
                    if (importedData.categories) {
                        categories = importedData.categories;
                        localStorage.setItem('categories', JSON.stringify(categories));
                    }
                    loadGoals(); // Recharger tout l'affichage
                    loadNotes();
                    alert('Données importées avec succès !');
                }
            } catch (error) {
                alert('Erreur lors de l\'importation des données : ' + error.message);
                console.error(error);
            }
        };
        reader.readAsText(file);
    }

    // --- Dark Mode ---
    document.addEventListener('DOMContentLoaded', () => {
        // Détruire tous les graphiques existants avant de les recréer
        for (const chartId in activeCharts) {
            if (activeCharts[chartId]) {
                activeCharts[chartId].destroy();
            }
        }
        activeCharts = {}; // Réinitialiser le cache des graphiques

        loadGoals(); // Charge les objectifs (incluant categories, et déclenche renderGoals)
        loadNotes(); // Charge les notes et les rend
        toggleGoalTypeFields(); // Configure l'affichage initial des champs de type d'objectif

        // Load dark mode preference
        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').checked = true;
        }
        document.getElementById('darkModeToggle').addEventListener('change', () => {
            if (document.getElementById('darkModeToggle').checked) {
                document.body.classList.add('dark-mode');
                localStorage.setItem('darkMode', 'true');
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('darkMode', 'false');
            }
        });

        // Assurez-vous que les chronomètres sont correctement restaurés (état du bouton)
        // Le temps enregistré est déjà dans `goal.currentTimerTime`
        goals.forEach((goal, idx) => {
            if (goal.type === 'numeric' && goal.currentTimerTime !== undefined) {
                const timerDisplay = document.getElementById(`timerDisplay-${idx}`);
                if (timerDisplay) {
                    timerDisplay.textContent = formatTime(goal.currentTimerTime);
                }
                const timerBtn = document.getElementById(`timerBtn-${idx}`);
                if (timerBtn) {
                    timerBtn.textContent = 'Start Timer'; // Par défaut après rechargement
                }
            }
        });

        // Vérifier et déclencher les rappels toutes les minutes
        setInterval(() => {
            let reminders = JSON.parse(localStorage.getItem('reminders')) || [];
            const now = Date.now();
            reminders.forEach(r => {
                if (!r.sent && now >= r.time) {
                    sendNotification('Rappel d\'Objectif: ' + r.goalName, 'Il est temps de mettre à jour votre objectif ou de travailler dessus !');
                    r.sent = true; // Marquer comme envoyé
                }
            });
            localStorage.setItem('reminders', JSON.stringify(reminders)); // Sauvegarder l'état mis à jour
        }, 60 * 1000); // Vérifier toutes les minutes (60 secondes * 1000 ms)

        // Show goals view by default and set active button
        showView('goalsView');
    });

    // --- Notifications API ---
    function requestNotificationPermission() {
        if (!('Notification' in window)) {
            alert('Ce navigateur ne supporte pas les notifications de bureau.');
            return;
        }

        Notification.requestPermission().then(permission => {
            if (permission === 'granted') {
                console.log('Permission de notification accordée.');
                alert('Les notifications sont activées !');
            } else {
                console.warn('Permission de notification refusée ou bloquée.');
                alert('Les notifications ont été refusées ou bloquées.');
            }
        });
    }

    function sendNotification(title, body) {
        if ('Notification' in window && Notification.permission === 'granted') {
            navigator.serviceWorker.ready.then(registration => {
                registration.showNotification(title, {
                    body: body,
                    icon: 'icon-192.png',
                    vibrate: [200, 100, 200],
                    tag: 'progress-tracker-notification-' + Date.now() // Utiliser un tag unique
                });
            });
        } else {
            console.warn('Notifications non autorisées ou non supportées.');
        }
    }

    function scheduleGoalReminder(goalName, timeInMinutes, goalId) {
        const time = parseInt(timeInMinutes);
        if (isNaN(time) || time <= 0) {
            alert('Veuillez entrer une durée valide en minutes (nombre positif).');
            return;
        }
        if (Notification.permission !== 'granted') {
            alert('Veuillez d\'abord activer les notifications dans les paramètres.');
            return;
        }

        const reminderTime = Date.now() + (time * 60 * 1000);
        const reminder = {
            goalName: goalName,
            time: reminderTime,
            goalId: goalId,
            sent: false
        };
        let reminders = JSON.parse(localStorage.getItem('reminders')) || [];
        reminders.push(reminder);
        localStorage.setItem('reminders', JSON.stringify(reminders));
        alert(`Rappel pour "${goalName}" programmé dans ${time} minutes.`);
        console.log(`Rappel pour "${goalName}" programmé à ${new Date(reminderTime).toLocaleString()}.`);
    }

    // --- Fonctions pour les objectifs récurrents ---
    function toggleGoalTypeFields() {
        const goalType = document.getElementById('newGoalType').value;
        const numericFields = document.getElementById('numericGoalFields');
        const recurringFields = document.getElementById('recurringGoalFields');

        numericFields.style.display = 'none';
        recurringFields.style.display = 'none';

        if (goalType === 'numeric') {
            numericFields.style.display = 'block';
        } else if (goalType === 'recurring') {
            recurringFields.style.display = 'block';
        }
    }

    function toggleRecurringGoal(index) {
        const goal = goals[index];
        const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD

        if (!goal.checkedDates[today]) {
            goal.checkedDates[today] = true;
            triggerCelebration();
            sendNotification(`Habitude accomplie !`, `Vous avez accompli "${goal.name}" aujourd'hui !`);
        } else {
            delete goal.checkedDates[today]; // Permet de décocher
        }
        saveGoals();
        renderGoals();
    }

    function showRecurringLog(index) {
        const logDiv = document.getElementById(`recurringLog-${index}`);
        const goal = goals[index];
        if (logDiv.style.display === 'block') {
            logDiv.style.display = 'none';
        } else {
            logDiv.innerHTML = '<h4>Historique des Habitudes :</h4>';
            const ul = document.createElement('ul');
            const sortedDates = Object.keys(goal.checkedDates).sort((a, b) => new Date(b) - new Date(a)); // Les plus récents en premier

            const displayLimit = 30;
            for (let i = 0; i < Math.min(sortedDates.length, displayLimit); i++) {
                const date = sortedDates[i];
                const li = document.createElement('li');
                li.textContent = `${new Date(date).toLocaleDateString('fr-FR')} : ${goal.checkedDates[date] ? 'Fait ✔️' : 'Non Fait ❌'}`;
                ul.appendChild(li);
            }

            if (sortedDates.length === 0) {
                logDiv.innerHTML += '<p>Aucune entrée pour cette habitude.</p>';
            } else {
                logDiv.appendChild(ul);
            }
            logDiv.style.display = 'block';
        }
    }

    // Service Worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(error => {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>