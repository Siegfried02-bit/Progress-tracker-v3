<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Progress Tracker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="header-nav">
    <button id="goalsButton" onclick="showView('goalsView')">Objectifs</button>
    <button id="notesButton" onclick="showView('notesView')">Notes</button>
  </div>

  <div id="goalsView" class="view">
    <h1>Progress Tracker</h1>

    <div class="main-content-flex">
        <div class="left-panel">
            <div class="add-goal-section">
                <h2>Ajouter un nouvel objectif :</h2>
                <label>Nom de l'objectif : <input type="text" id="newName"></label>
                <span class="error-message" id="error-newName"></span><br>

                <label>Type d'objectif :
                    <select id="newGoalType" onchange="toggleGoalTypeFields()">
                        <option value="numeric">Numérique (ex: lire X pages)</option>
                        <option value="boolean">À faire (ex: terminer une tâche)</option>
                        <option value="recurring">Récurrent / Habitude (ex: sport quotidien)</option>
                    </select>
                </label><br>

                <div id="numericGoalFields">
                    <label>Cible : <input type="number" id="newTarget"></label>
                    <span class="error-message" id="error-newTarget"></span><br>
                    <label>Unité (optionnel) : <input type="text" id="newUnit" placeholder="ex: pages, km, heures"></label><br>
                </div>
                
                <div id="recurringGoalFields" style="display:none;">
                    <label>Fréquence :
                        <select id="newRecurringFrequency">
                            <option value="daily">Quotidien</option>
                            <option value="weekly">Hebdomadaire</option>
                        </select>
                    </label><br>
                </div>


                <label>Catégorie :
                    <div id="categorySelectContainer" style="display: flex; flex-wrap: wrap; align-items: center;">
                        <select id="newCategory" style="flex-grow: 1; max-width: 250px; margin-right: 10px;"></select>
                        <button onclick="addCustomCategory()">Ajouter une catégorie personnalisée</button>
                    </div>
                </label><br>
                
                <label>Date d'échéance (optionnel, pour objectifs numériques/à faire) : <input type="date" id="newDueDate"></label><br>

                <button onclick="addGoal()">Ajouter un objectif</button>
            </div>
        </div>

        <div class="right-panel">
            <div class="statistics-section">
                <h2>Statistiques des objectifs :</h2>
                <p>Total d'objectifs : <span id="totalGoals">0</span></p>
                <p>Objectifs complétés : <span id="completedGoals">0</span></p>
                <p>Objectifs en attente : <span id="pendingGoals">0</span></p>
                <h3>Objectifs par catégorie :</h3>
                <ul id="goalsByCategory"></ul>
                <h3>Statistiques de temps globales :</h3>
                <p>Temps total passé sur les objectifs : <span id="totalTimeAllGoals">00:00:00</span></p>
                <p>Temps passé aujourd'hui : <span id="timeSpentTodayAllGoals">00:00:00</span></p>
            </div>
        </div>
    </div>

    <div class="manage-category-toggle-section">
        <h2 onclick="toggleManageCategories()" style="cursor: pointer;">Gérer les catégories <span id="toggleManageCategoryArrow" class="arrow-down"></span></h2>
        <div id="manageCategoryContent" style="display: none;">
            <div id="categoryList"></div>
        </div>
    </div>

    <div class="filter-sort-section">
        <h2>Filtrer & trier les objectifs :</h2>
        <label>Filtrer par catégorie :</label>
        <div id="filterCategoryCheckboxes" class="category-checkboxes">
            </div>
        <label>Trier par :
            <select id="sortBy" onchange="renderGoals()">
                <option value="name">Nom</option>
                <option value="progressAsc">Progression (Croissant)</option>
                <option value="progressDesc">Progression (Décroissant)</option>
                <option value="creationDate">Date de création</option>
                <option value="dueDate">Date d'échéance</option>
            </select>
        </label>
        <label>Rechercher : <input type="text" id="searchGoals" onkeyup="renderGoals()" placeholder="Rechercher des objectifs..."></label>
        <label class="checkbox-container">Afficher les objectifs complétés/archivés
            <input type="checkbox" id="showCompleted" onchange="renderGoals()">
            <span class="checkmark"></span>
        </label>
    </div>

    <div id="goalsContainer"></div>

    <div class="daily-log-section">
        <h2>Consultation du temps passé par jour :</h2>
        <label>Sélectionnez une date : <input type="date" id="dailyLogDate"></label>
        <button onclick="displayDailyLog()">Afficher les détails</button>
        <div id="dailyLogDetails" class="daily-log-details" style="display:none;">
            <h3>Détails pour la date sélectionnée : <span id="selectedDateDisplay"></span></h3>
            <p>Temps total passé : <span id="selectedDateTotalTime">00:00:00</span></p>
            <h4>Détail par objectif :</h4>
            <ul id="selectedDateGoalsDetails"></ul>
        </div>
    </div>

    <div class="utility-buttons">
        <button onclick="toggleDarkMode()">Mode Sombre</button>
        <button onclick="exportGoals()">Exporter les objectifs</button>
        <input type="file" accept=".json" onchange="importGoals(event)">
    </div>
  </div>

  <div id="notesView" class="view">
    <h1>Mes Notes</h1>

    <div class="add-note-section">
        <h2>Ajouter une nouvelle note :</h2>
        <label>Titre de la note : <input type="text" id="newNoteTitle"></label>
        <span class="error-message" id="error-newNoteTitle"></span><br>
        <label>Contenu de la note : <textarea id="newNoteContent"></textarea></label><br>
        <label>Catégorie de la note :
            <select id="newNoteCategory"></select>
        </label><br>
        <button onclick="addNote()">Ajouter la note</button>
    </div>

    <div class="filter-sort-section">
        <h2>Filtrer & trier les notes :</h2>
        <label>Filtrer par catégorie :
          <select id="filterNoteCategory" onchange="renderNotes()">
            <option value="all">Toutes</option>
          </select>
        </label>
        <label>Rechercher : <input type="text" id="searchNotes" onkeyup="renderNotes()" placeholder="Rechercher des notes..."></label>
    </div>

    <div id="notesContainer"></div>
  </div>


  <div id="toastNotification" class="toast-notification"></div>
  <div id="undoNotification" class="undo-notification">
    Action annulée ! <button onclick="confirmUndo()">Confirmer</button>
  </div>
  
  <div id="chartModal" class="modal">
      <div class="modal-content">
        <span class="close-button" onclick="closeChartModal()">&times;</span>
        <h2 id="chartTitle">Graphique de Progression</h2>
        <canvas id="progressChart"></canvas>
      </div>
  </div>


  <script>
    let goals = [];
    let categories = ['Sport', 'Travail', 'Personnel', 'Autre']; // Default categories
    let notes = []; // Array for notes
    let previousGoalsState = null;
    let undoTimeout = null;
    let overallDailyTimeLogs = {}; // Global object to store daily time logs for all goals
    let progressChartInstance = null; // To hold the chart instance

    // --- Utility Functions ---
    function formatTime(seconds) {
        if (seconds < 0) seconds = 0;
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return [h, m, s]
            .map(v => v < 10 ? '0' + v : v)
            .join(':');
    }

    function getTodayDateString() {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // --- View Management ---
    function showView(viewId) {
        document.querySelectorAll('.view').forEach(view => {
            view.style.display = 'none';
            view.classList.remove('active');
        });
        document.querySelectorAll('.header-nav button').forEach(button => {
            button.classList.remove('active');
        });

        const activeView = document.getElementById(viewId);
        activeView.style.display = 'block';
        activeView.classList.add('active');
        
        document.getElementById(viewId === 'goalsView' ? 'goalsButton' : 'notesButton').classList.add('active');

        if (viewId === 'goalsView') {
            loadGoals();
        } else if (viewId === 'notesView') {
            loadNotes();
        }
    }

    // --- Goals Functions ---
    function loadGoals() {
      const savedGoals = localStorage.getItem('goals');
      if (savedGoals) {
        goals = JSON.parse(savedGoals);
        goals.forEach(goal => {
            if (typeof goal.isTimerRunning === 'undefined') goal.isTimerRunning = false;
            if (typeof goal.timerStartTime === 'undefined') goal.timerStartTime = null;
            if (typeof goal.totalTimeLogged === 'undefined') goal.totalTimeLogged = 0;
            if (typeof goal.dailyTimeLogs === 'undefined') goal.dailyTimeLogs = {};
            if (goal.type === 'recurring' && typeof goal.completedToday === 'undefined') {
                goal.completedToday = false;
                goal.streak = goal.streak || 0;
                goal.lastCompleted = goal.lastCompleted || null;
            }
        });
      }
      const savedCategories = localStorage.getItem('categories');
      if (savedCategories) {
        categories = JSON.parse(savedCategories);
      }
      const savedOverallDailyTimeLogs = localStorage.getItem('overallDailyTimeLogs');
      if (savedOverallDailyTimeLogs) {
          overallDailyTimeLogs = JSON.parse(savedOverallDailyTimeLogs);
      }
      checkAndResetRecurringGoals();
      populateCategories();
      populateFilterCategories();
      renderGoals();
      updateStatistics();
    }

    function saveGoals() {
      localStorage.setItem('goals', JSON.stringify(goals));
      updateStatistics();
    }

    function saveCategories() {
      localStorage.setItem('categories', JSON.stringify(categories));
    }
    
    function saveOverallDailyTimeLogs() {
        localStorage.setItem('overallDailyTimeLogs', JSON.stringify(overallDailyTimeLogs));
    }

    function populateCategories() {
      const selectElement = document.getElementById('newCategory');
      selectElement.innerHTML = '';
      categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category;
        option.textContent = category;
        selectElement.appendChild(option);
      });
      addCategoryManageButtons();
      populateNoteCategories();
    }

    function populateFilterCategories() {
        const filterCategoryCheckboxesDiv = document.getElementById('filterCategoryCheckboxes');
        filterCategoryCheckboxesDiv.innerHTML = '';

        const allCheckbox = document.createElement('label');
        allCheckbox.className = 'checkbox-container';
        allCheckbox.innerHTML = `Toutes
            <input type="checkbox" value="all" checked onchange="toggleAllCategories(this)">
            <span class="checkmark"></span>
        `;
        filterCategoryCheckboxesDiv.appendChild(allCheckbox);

        categories.forEach(category => {
            const label = document.createElement('label');
            label.className = 'checkbox-container';
            label.innerHTML = `${category}
                <input type="checkbox" value="${category}" onchange="renderGoals()">
                <span class="checkmark"></span>
            `;
            filterCategoryCheckboxesDiv.appendChild(label);
        });
    }

    function toggleAllCategories(checkbox) {
        const checkboxes = document.querySelectorAll('#filterCategoryCheckboxes input[type="checkbox"]');
        checkboxes.forEach(cb => {
            if (cb.value !== 'all') {
                cb.checked = checkbox.checked;
            }
        });
        renderGoals();
    }

    function getSelectedCategories() {
        const selected = [];
        document.querySelectorAll('#filterCategoryCheckboxes input[type="checkbox"]:checked').forEach(cb => {
            if (cb.value !== 'all') {
                selected.push(cb.value);
            }
        });
        // If "All" is checked, return all categories
        if (document.querySelector('#filterCategoryCheckboxes input[value="all"]').checked) {
            return categories;
        }
        return selected;
    }


    function addCategoryManageButtons() {
        const categoryListDiv = document.getElementById('categoryList');
        categoryListDiv.innerHTML = '';

        categories.forEach(category => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'category-list-item';
            
            let buttonsHtml = '';
            if (!['Sport', 'Travail', 'Personnel', 'Autre'].includes(category)) {
                 buttonsHtml = `
                    <div>
                        <button class="edit-category-btn" onclick="editCategory('${category}')">Modifier</button>
                        <button class="delete-category-btn" onclick="deleteCategory('${category}')">&times;</button>
                    </div>
                `;
            }
            itemDiv.innerHTML = `<span>${category}</span> ${buttonsHtml}`;
            categoryListDiv.appendChild(itemDiv);
        });
    }

    function editCategory(oldName) {
        const newName = prompt(`Entrez le nouveau nom pour la catégorie "${oldName}":`, oldName);
        if (!newName || newName.trim() === '' || newName.trim() === oldName) {
            showToast('Modification annulée ou nom inchangé.', 'info');
            return;
        }
        const trimmedNewName = newName.trim();
        if (categories.includes(trimmedNewName)) {
            showToast('Cette catégorie existe déjà.', 'error');
            return;
        }

        const catIndex = categories.indexOf(oldName);
        if (catIndex > -1) {
            categories[catIndex] = trimmedNewName;
        }

        goals.forEach(goal => { if (goal.category === oldName) goal.category = trimmedNewName; });
        notes.forEach(note => { if (note.category === oldName) note.category = trimmedNewName; });

        saveCategories();
        saveGoals();
        saveNotes();

        populateCategories();
        populateFilterCategories();
        renderGoals();
        renderNotes();
        showToast(`Catégorie "${oldName}" renommée en "${trimmedNewName}".`, 'success');
    }


    function deleteCategory(categoryToDelete) {
        if (['Sport', 'Travail', 'Personnel', 'Autre'].includes(categoryToDelete)) {
            showToast('Les catégories par défaut ne peuvent pas être supprimées.', 'warning');
            return;
        }

        if (confirm(`Voulez-vous vraiment supprimer la catégorie "${categoryToDelete}" ? Les objectifs et notes associés seront déplacés dans 'Autre'.`)) {
            categories = categories.filter(cat => cat !== categoryToDelete);
            saveCategories();
            goals.forEach(goal => { if (goal.category === categoryToDelete) goal.category = 'Autre'; });
            saveGoals();
            notes.forEach(note => { if (note.category === categoryToDelete) note.category = 'Autre'; });
            saveNotes();
            populateCategories();
            populateFilterCategories();
            populateNoteCategories();
            renderGoals();
            renderNotes();
            showToast(`Catégorie "${categoryToDelete}" supprimée.`, 'info');
        }
    }

    function toggleManageCategories() {
        const content = document.getElementById('manageCategoryContent');
        const arrow = document.getElementById('toggleManageCategoryArrow');
        if (content.style.display === 'none') {
            content.style.display = 'block';
            arrow.classList.remove('arrow-down');
            arrow.classList.add('arrow-up');
        } else {
            content.style.display = 'none';
            arrow.classList.remove('arrow-up');
            arrow.classList.add('arrow-down');
        }
    }


    function validateForm() {
        let isValid = true;
        const nameInput = document.getElementById('newName');
        const targetInput = document.getElementById('newTarget');
        const nameError = document.getElementById('error-newName');
        const targetError = document.getElementById('error-newTarget');
        const goalType = document.getElementById('newGoalType').value;

        nameError.textContent = '';
        nameInput.classList.remove('is-invalid');
        targetError.textContent = '';
        targetInput.classList.remove('is-invalid');

        if (!nameInput.value.trim()) {
            nameError.textContent = 'Le nom de l\'objectif ne peut pas être vide.';
            nameInput.classList.add('is-invalid');
            isValid = false;
        }

        if (goalType === 'numeric') {
            const target = parseInt(targetInput.value);
            if (isNaN(target) || target <= 0) {
                targetError.textContent = 'La cible doit être un nombre positif.';
                targetInput.classList.add('is-invalid');
                isValid = false;
            }
        }
        return isValid;
    }

    function addCustomCategory() {
      const customCategory = prompt("Entrez le nom de la nouvelle catégorie :");
      if (customCategory && customCategory.trim() !== '') {
        const trimmedCategory = customCategory.trim();
        if (!categories.includes(trimmedCategory)) {
          categories.push(trimmedCategory);
          saveCategories();
          populateCategories();
          populateFilterCategories();
          document.getElementById('newCategory').value = trimmedCategory;
          showToast(`Catégorie "${trimmedCategory}" ajoutée !`, 'success');
        } else {
          showToast("La catégorie existe déjà !", 'warning');
        }
      }
    }

    function addGoal() {
      if (!validateForm()) {
        showToast('Veuillez corriger les erreurs du formulaire.', 'error');
        return;
      }

      const name = document.getElementById('newName').value.trim();
      const category = document.getElementById('newCategory').value;
      const goalType = document.getElementById('newGoalType').value;

      let goalData = {
          name,
          category,
          creationDate: new Date().toISOString(),
          type: goalType,
          isTimerRunning: false,
          timerStartTime: null,
          totalTimeLogged: 0,
          dailyTimeLogs: {},
          history: [] 
      };

      if (goalType === 'numeric') {
          goalData.target = parseInt(document.getElementById('newTarget').value);
          goalData.current = 0;
          goalData.unit = document.getElementById('newUnit').value.trim();
          goalData.dueDate = document.getElementById('newDueDate').value || null;
      } else if (goalType === 'boolean'){
          goalData.completed = false;
          goalData.dueDate = document.getElementById('newDueDate').value || null;
      } else { // recurring
          goalData.frequency = document.getElementById('newRecurringFrequency').value;
          goalData.streak = 0;
          goalData.completedToday = false;
          goalData.lastCompleted = null;
      }

      goals.push(goalData);
      saveGoals();
      renderGoals();
      
      document.getElementById('newName').value = '';
      document.getElementById('newTarget').value = '';
      document.getElementById('newUnit').value = '';
      document.getElementById('newCategory').selectedIndex = 0;
      document.getElementById('newDueDate').value = '';
      document.getElementById('newGoalType').value = 'numeric';
      toggleGoalTypeFields();
      showToast('Objectif ajouté avec succès !', 'success');
    }

    function updateGoal(index) {
        previousGoalsState = JSON.parse(JSON.stringify(goals));
        const goal = goals[index];
        if (goal.type === 'numeric') {
            const progressInput = document.getElementById(`progress-${index}`);
            const progress = parseInt(progressInput.value);
            if (!isNaN(progress) && progress !== 0) {
                const wasCompleted = goal.current >= goal.target;
                goal.current += progress;
                if (goal.current < 0) goal.current = 0;
                
                goal.history.push({ date: new Date().toISOString(), value: progress, cumulative: goal.current });
                saveGoals();
                renderGoals();
                progressInput.value = '';

                const isNowCompleted = goal.current >= goal.target;
                if (isNowCompleted && !wasCompleted) {
                    const goalElement = document.querySelector(`.goal[data-index="${index}"]`);
                    if (goalElement) triggerConfetti(goalElement);
                    showToast(`Objectif "${goal.name}" complété !`, 'success');
                }
            } else {
                showToast('Veuillez entrer un nombre valide pour la progression.', 'error');
            }
        } else { // boolean
            const wasCompleted = goal.completed;
            goal.completed = !goal.completed;
            goal.history.push({ date: new Date().toISOString(), value: goal.completed ? 'Complété' : 'Non coché' });
            saveGoals();
            renderGoals();
            if (goal.completed && !wasCompleted) {
                const goalElement = document.querySelector(`.goal[data-index="${index}"]`);
                if (goalElement) triggerConfetti(goalElement);
                showToast(`Objectif "${goal.name}" marqué comme complété !`, 'success');
            } else {
                showToast(`Objectif "${goal.name}" marqué comme incomplet.`, 'info');
            }
        }
        showUndoNotification();
    }
    
    // --- Recurring Goals Functions ---
    function checkAndResetRecurringGoals() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        goals.forEach(goal => {
            if (goal.type !== 'recurring' || !goal.lastCompleted) return;

            const lastCompletedDate = new Date(goal.lastCompleted);
            lastCompletedDate.setHours(0, 0, 0, 0);

            if (goal.frequency === 'daily') {
                const diffDays = (today - lastCompletedDate) / (1000 * 60 * 60 * 24);
                if (diffDays >= 1) {
                    goal.completedToday = false;
                    if (diffDays > 1) {
                        goal.streak = 0; // Reset streak if a day was missed
                    }
                }
            } else if (goal.frequency === 'weekly') {
                const endOfLastCompletedWeek = new Date(lastCompletedDate);
                endOfLastCompletedWeek.setDate(lastCompletedDate.getDate() + (7 - lastCompletedDate.getDay()));
                
                if (today > endOfLastCompletedWeek) {
                     goal.completedToday = false; // "completedToday" means "this period"
                     // Check if the next week was missed for streak reset
                     const endOfNextWeek = new Date(endOfLastCompletedWeek);
                     endOfNextWeek.setDate(endOfLastCompletedWeek.getDate() + 7);
                     if(today > endOfNextWeek) {
                        goal.streak = 0;
                     }
                }
            }
        });
        saveGoals();
    }

    function completeRecurringGoal(index) {
        previousGoalsState = JSON.parse(JSON.stringify(goals));
        const goal = goals[index];
        
        goal.completedToday = true;
        goal.lastCompleted = new Date().toISOString();
        goal.streak += 1;
        goal.history.push({ date: new Date().toISOString(), value: `Complété (Série: ${goal.streak})` });

        const goalElement = document.querySelector(`.goal[data-index="${index}"]`);
        if (goalElement) triggerConfetti(goalElement);

        saveGoals();
        renderGoals();
        showToast(`Habitude "${goal.name}" complétée ! Série de ${goal.streak} !`, 'success');
        showUndoNotification();
    }


    function resetGoal(index) {
      if (confirm('Êtes-vous sûr de vouloir réinitialiser la progression de cet objectif à zéro ?')) {
        previousGoalsState = JSON.parse(JSON.stringify(goals));
        goals[index].current = 0;
        goals[index].history.push({ date: new Date().toISOString(), value: 'Réinitialisé' });
        saveGoals();
        renderGoals();
        showToast('Progression de l\'objectif réinitialisée !', 'info');
        showUndoNotification();
      }
    }

    function editGoal(index) {
      // Implementation similar to original, omitted for brevity but should be kept
      // ... same logic as in the original file ...
    }


    function deleteGoal(index) {
      if (confirm('Êtes-vous sûr de vouloir supprimer cet objectif ? Cette action ne peut pas être annulée.')) {
        previousGoalsState = JSON.parse(JSON.stringify(goals));
        if (goals[index].isTimerRunning) {
            stopGoalTimer(index);
        }
        goals.splice(index, 1);
        saveGoals();
        renderGoals();
        showToast('Objectif supprimé !', 'warning');
        showUndoNotification();
      }
    }

    // --- Timer Functions for Goals ---
    let goalTimers = {};
    // ... same timer functions as in the original file (startGoalTimer, stopGoalTimer) ...
     function startGoalTimer(index) {
        const goal = goals[index];
        if (goal.isTimerRunning) {
            showToast(`Le chronomètre pour "${goal.name}" est déjà en cours.`, 'warning');
            return;
        }
        goal.isTimerRunning = true;
        goal.timerStartTime = Date.now();
        saveGoals();
        renderGoals();
        showToast(`Chronomètre démarré pour "${goal.name}" !`, 'success');
    }

    function stopGoalTimer(index) {
        const goal = goals[index];
        if (!goal.isTimerRunning) {
            showToast(`Le chronomètre pour "${goal.name}" n'est pas en cours.`, 'warning');
            return;
        }
        const durationMs = Date.now() - goal.timerStartTime;
        const durationSeconds = Math.floor(durationMs / 1000);
        goal.totalTimeLogged += durationSeconds;
        const todayDate = getTodayDateString();
        if (!goal.dailyTimeLogs[todayDate]) goal.dailyTimeLogs[todayDate] = 0;
        goal.dailyTimeLogs[todayDate] += durationSeconds;

        if (!overallDailyTimeLogs[todayDate]) overallDailyTimeLogs[todayDate] = { totalSeconds: 0, goals: {} };
        overallDailyTimeLogs[todayDate].totalSeconds += durationSeconds;
        if (!overallDailyTimeLogs[todayDate].goals[goal.name]) overallDailyTimeLogs[todayDate].goals[goal.name] = 0;
        overallDailyTimeLogs[todayDate].goals[goal.name] += durationSeconds;

        goal.isTimerRunning = false;
        goal.timerStartTime = null;
        saveGoals();
        saveOverallDailyTimeLogs();
        renderGoals();
        showToast(`Chronomètre arrêté pour "${goal.name}". Temps enregistré : ${formatTime(durationSeconds)}.`, 'info');
    }


    function renderGoals() {
      const container = document.getElementById('goalsContainer');
      container.innerHTML = '';
      let displayedGoals = [...goals];

      // --- Archiving Filter ---
      const showCompleted = document.getElementById('showCompleted').checked;
      if (!showCompleted) {
          displayedGoals = displayedGoals.filter(goal => {
              if (goal.type === 'numeric') return goal.current < goal.target;
              if (goal.type === 'boolean') return !goal.completed;
              return true; // Recurring goals are always shown unless filtered by other means
          });
      }

      const selectedCategories = getSelectedCategories();
      if (selectedCategories.length > 0 && !(selectedCategories.length === 1 && selectedCategories[0] === 'all')) {
          displayedGoals = displayedGoals.filter(goal => selectedCategories.includes(goal.category));
      }

      const searchTerm = document.getElementById('searchGoals').value.toLowerCase();
      if (searchTerm) {
        displayedGoals = displayedGoals.filter(goal =>
          goal.name.toLowerCase().includes(searchTerm) ||
          goal.category.toLowerCase().includes(searchTerm)
        );
      }
      
      const sortBy = document.getElementById('sortBy').value;
      displayedGoals.sort((a, b) => { /* ... same sorting logic ... */ });

      if (displayedGoals.length === 0) {
        container.innerHTML = '<p class="no-goals-message">Aucun objectif à afficher.</p>';
        return;
      }

      displayedGoals.forEach((goal) => {
        const originalIndex = goals.findIndex(g => g.creationDate === goal.creationDate && g.name === goal.name);
        const goalDiv = document.createElement('div');
        goalDiv.className = 'goal';
        goalDiv.setAttribute('data-index', originalIndex);

        let progressHtml = '';
        let isCompleted = false;

        if (goal.type === 'numeric') {
            isCompleted = goal.current >= goal.target;
            const percentage = isCompleted ? 100 : (goal.current / goal.target) * 100;
            const statusText = isCompleted ? 'Complété !' : `${goal.current} / ${goal.target} ${goal.unit || ''} (${percentage.toFixed(1)}%)`;
            goalDiv.classList.toggle('completed-goal', isCompleted);
            progressHtml = `
                <p>Progression: <span class="${isCompleted ? 'goal-completed-text' : ''}">${statusText}</span></p>
                <div class="progress-bar ${isCompleted ? 'completed-bar' : ''}"><div class="progress" style="width: ${percentage}%"></div></div>
                <label>Ajouter progression: <input type="number" id="progress-${originalIndex}" ${isCompleted ? 'disabled' : ''}></label>
                <button onclick="updateGoal(${originalIndex})" ${isCompleted ? 'disabled' : ''}>Mettre à jour</button>
                <button onclick="resetGoal(${originalIndex})">Réinitialiser</button>
                <button onclick="showProgressGraph(${originalIndex})">Voir le graphique</button>
            `;
        } else if (goal.type === 'boolean') {
            isCompleted = goal.completed;
            const statusText = isCompleted ? 'Complété' : 'Incomplet';
            goalDiv.classList.toggle('completed-goal', isCompleted);
            progressHtml = `
                <p>Statut: <span class="status-boolean ${isCompleted ? 'completed' : 'incomplete'}">${statusText}</span></p>
                <label class="checkbox-container"> Marquer comme ${isCompleted ? 'Incomplet' : 'Complet'}
                    <input type="checkbox" ${isCompleted ? 'checked' : ''} onchange="updateGoal(${originalIndex})">
                    <span class="checkmark"></span>
                </label>
            `;
        } else { // recurring
            isCompleted = goal.completedToday;
            goalDiv.classList.toggle('completed-goal', isCompleted);
            progressHtml = `
                <div class="recurring-goal-info">
                    <p>Statut aujourd'hui: <span class="status-boolean ${isCompleted ? 'completed' : 'incomplete'}">${isCompleted ? 'Fait !' : 'À faire'}</span></p>
                    <p>Série actuelle : <strong>${goal.streak}</strong></p>
                    <button onclick="completeRecurringGoal(${originalIndex})" ${isCompleted ? 'disabled' : ''}>Fait pour aujourd'hui !</button>
                </div>
            `;
        }

        let dueDateHtml = '';
        if (goal.dueDate) { /* ... same due date logic ... */ }

        const timerControlsHtml = `...`; // Keep original timer logic

        goalDiv.innerHTML = `
          <button class="delete-goal-btn" onclick="deleteGoal(${originalIndex})">&times;</button>
          <h3>${goal.name} (${goal.category})</h3>
          ${dueDateHtml}
          ${progressHtml}
          <button onclick="toggleHistory(${originalIndex})">Voir l'historique</button>
        `;
        container.appendChild(goalDiv);
      });
    }
    
    // --- Charting Functions ---
    function showProgressGraph(index) {
        const goal = goals[index];
        if (goal.type !== 'numeric' || !goal.history || goal.history.length === 0) {
            showToast('Aucun historique de progression à afficher pour ce graphique.', 'info');
            return;
        }

        const chartModal = document.getElementById('chartModal');
        const chartTitle = document.getElementById('chartTitle');
        chartTitle.textContent = `Graphique de Progression: ${goal.name}`;

        const labels = ['Début'];
        const data = [0];
        
        goal.history.forEach(entry => {
            if (typeof entry.cumulative !== 'undefined') {
                labels.push(new Date(entry.date).toLocaleDateString());
                data.push(entry.cumulative);
            }
        });

        const ctx = document.getElementById('progressChart').getContext('2d');
        if(progressChartInstance) {
            progressChartInstance.destroy(); // Destroy previous chart instance
        }
        progressChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: `Progression Cumulative (${goal.unit || ''})`,
                    data: data,
                    borderColor: '#007bff',
                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                    fill: true,
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        suggestedMax: goal.target
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Objectif Cible: ${goal.target} ${goal.unit || ''}`
                    }
                }
            }
        });

        chartModal.style.display = 'block';
    }

    function closeChartModal() {
        document.getElementById('chartModal').style.display = 'none';
    }

    function toggleHistory(index) {
      const goal = goals[index];
      const historyDisplay = document.getElementById(`history-display-${index}`);

      if (historyDisplay.style.display === 'none') {
        if (goal && goal.history && goal.history.length > 0) {
          historyDisplay.innerHTML = '<h4>Historique de progression :</h4><ul>' +
            goal.history.map(h => `<li>${new Date(h.date).toLocaleString('fr-FR')}: ${h.value}</li>`).join('') +
            '</ul>';
        } else {
          historyDisplay.innerHTML = '<p>Aucun historique disponible.</p>';
        }
        historyDisplay.style.display = 'block';
      } else {
        historyDisplay.style.display = 'none';
        historyDisplay.innerHTML = '';
      }
    }

    function toggleGoalTypeFields() {
        const goalType = document.getElementById('newGoalType').value;
        const numericFields = document.getElementById('numericGoalFields');
        const recurringFields = document.getElementById('recurringGoalFields');
        const dueDateField = document.querySelector('label[for="newDueDate"]');

        numericFields.style.display = 'none';
        recurringFields.style.display = 'none';
        dueDateField.style.display = 'block';

        if (goalType === 'numeric') {
            numericFields.style.display = 'block';
        } else if (goalType === 'recurring') {
            recurringFields.style.display = 'block';
            dueDateField.style.display = 'none';
        }
    }


    // --- Other functions (statistics, notes, utilities) ---
    // Keep all other functions from the original file:
    // updateStatistics, loadNotes, saveNotes, populateNoteCategories, addNote, renderNotes,
    // editNote, deleteNote, showToast, showUndoNotification, confirmUndo, hideUndoNotification,
    // triggerConfetti, toggleDarkMode, Reminder Functions, Daily Log Functions, exportGoals, importGoals
    
    // ... (All other functions from your original file should be here) ...


    // --- Initial setup on page load ---
    document.addEventListener('DOMContentLoaded', () => {
        loadGoals();
        loadNotes();
        toggleGoalTypeFields();

        if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-mode');
        }
        
        showView('goalsView'); 
    });


    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(registration => console.log('Service Worker registered.'))
          .catch(error => console.error('Service Worker registration failed:', error));
      });
    }
    
    // Dummy function for editGoal to avoid errors, replace with your original implementation
    function editGoal(index) {
        showToast('Fonction de modification à implémenter.', 'info');
        console.log('Editing goal at index:', index);
    }

  </script>
</body>
</html>